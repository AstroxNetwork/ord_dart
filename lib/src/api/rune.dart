// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:meta/meta.dart' as meta;
part 'rune.freezed.dart';

@freezed
sealed class Artifact with _$Artifact {
  const Artifact._();

  const factory Artifact.cenotaph(
    Cenotaph field0,
  ) = Artifact_Cenotaph;
  const factory Artifact.runestone(
    Runestone field0,
  ) = Artifact_Runestone;

  RuneId? mint() {
    return when(
      cenotaph: (cenotaph) => cenotaph.mint,
      runestone: (runestone) => runestone.mint,
    );
  }
}

@freezed
@meta.immutable
class Cenotaph with _$Cenotaph {
  const factory Cenotaph({
    Rune? etching,
    Flaw? flaw,
    RuneId? mint,
  }) = _Cenotaph;
}

@freezed
@meta.immutable
class Edict with _$Edict {
  const Edict._();
  const factory Edict({
    required RuneId id,
    required BigInt amount,
    required int output,
  }) = _Edict;
  static Edict? fromIntegers(
          {required String rawTx,
          required RuneId id,
          required BigInt amount,
          required BigInt output,
          dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneEdictFromIntegers(
          rawTx: rawTx, id: id, amount: amount, output: output, hint: hint);
}

@freezed
@meta.immutable
class Etching with _$Etching {
  const Etching._();
  const factory Etching({
    int? divisibility,
    BigInt? premine,
    Rune? rune,
    int? spacers,
    String? symbol,
    Terms? terms,
    bool? turbo,
  }) = _Etching;
  static int maxDivisibility({dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneEtchingMaxDivisibility(hint: hint);

  static int maxSpacers({dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneEtchingMaxSpacers(hint: hint);

  BigInt? supply({dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneEtchingSupply(that: this, hint: hint);
}

enum Flaw {
  edictOutput,
  edictRuneId,
  invalidScript,
  opcode,
  supplyOverflow,
  trailingIntegers,
  truncatedField,
  unrecognizedEvenTag,
  unrecognizedFlag,
  varint,
  ;
}

enum Network {
  /// Mainnet Bitcoin.
  bitcoin,

  /// Bitcoin's testnet network.
  testnet,

  /// Bitcoin's signet network.
  signet,

  /// Bitcoin's regtest network.
  regtest,
  ;
}

@freezed
@meta.immutable
class Rune with _$Rune {
  const Rune._();
  const factory Rune({
    required BigInt field0,
  }) = _Rune;
  Uint8List commitment({dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneRuneCommitment(that: this, hint: hint);

  static int firstRuneHeight({required Network network, dynamic hint}) =>
      OrdDart.instance.api
          .crateApiRuneRuneFirstRuneHeight(network: network, hint: hint);

  static Rune fromStr({required String s, dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneRuneFromStr(s: s, hint: hint);

  bool isReserved({dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneRuneIsReserved(that: this, hint: hint);

  static Rune minimumAtHeight(
          {required Network chain, required int height, dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneRuneMinimumAtHeight(
          chain: chain, height: height, hint: hint);

  BigInt n({dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneRuneN(that: this, hint: hint);

  static Rune reserved(
          {required BigInt block, required int tx, dynamic hint}) =>
      OrdDart.instance.api
          .crateApiRuneRuneReserved(block: block, tx: tx, hint: hint);

  @override
  String toString({dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneRuneToString(that: this, hint: hint);
}

@freezed
@meta.immutable
class RuneId with _$RuneId {
  const RuneId._();
  const factory RuneId({
    required BigInt block,
    required int tx,
  }) = _RuneId;
  (BigInt, BigInt)? delta({required RuneId next, dynamic hint}) =>
      OrdDart.instance.api
          .crateApiRuneRuneIdDelta(that: this, next: next, hint: hint);

  static RuneId fromStr({required String s, dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneRuneIdFromStr(s: s, hint: hint);

  RuneId? next({required BigInt block, required BigInt tx, dynamic hint}) =>
      OrdDart.instance.api
          .crateApiRuneRuneIdNext(that: this, block: block, tx: tx, hint: hint);

  @override
  String toString() {
    return '$block:$tx';
  }
}

@freezed
@meta.immutable
class Runestone with _$Runestone {
  const Runestone._();
  const factory Runestone({
    List<Edict>? edicts,
    Etching? etching,
    RuneId? mint,
    int? pointer,
  }) = _Runestone;
  static int commitConfirmations({dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneRunestoneCommitConfirmations(hint: hint);

  static Artifact? decipher({required String rawTx, dynamic hint}) =>
      OrdDart.instance.api
          .crateApiRuneRunestoneDecipher(rawTx: rawTx, hint: hint);

  static Future<Artifact?> decipherAsync(
          {required String rawTx, dynamic hint}) =>
      OrdDart.instance.api
          .crateApiRuneRunestoneDecipherAsync(rawTx: rawTx, hint: hint);

  Uint8List encipher({dynamic hint}) => OrdDart.instance.api
      .crateApiRuneRunestoneEncipher(that: this, hint: hint);

  Future<Uint8List> encipherAsync({dynamic hint}) => OrdDart.instance.api
      .crateApiRuneRunestoneEncipherAsync(that: this, hint: hint);

  static int magicNumber({dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneRunestoneMagicNumber(hint: hint);
}

@freezed
@meta.immutable
class SpacedRune with _$SpacedRune {
  const SpacedRune._();
  const factory SpacedRune({
    required Rune rune,
    required int spacers,
  }) = _SpacedRune;
  static SpacedRune fromStr({required String s, dynamic hint}) =>
      OrdDart.instance.api.crateApiRuneSpacedRuneFromStr(s: s, hint: hint);

  @override
  String toString({dynamic hint}) => OrdDart.instance.api
      .crateApiRuneSpacedRuneToString(that: this, hint: hint);
}

@freezed
@meta.immutable
class Terms with _$Terms {
  const factory Terms({
    BigInt? amount,
    BigInt? cap,
    (BigInt?, BigInt?)? height,
    (BigInt?, BigInt?)? offset,
  }) = _Terms;
}
